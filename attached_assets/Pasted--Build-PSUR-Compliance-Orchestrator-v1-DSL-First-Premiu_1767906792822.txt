# Build: PSUR Compliance Orchestrator v1 (DSL-First, Premium)

You are an expert software engineer building a deterministic compliance kernel for PSUR generation.
Build a local-first Python project that:
- Encodes PSUR obligations & constraints as a DSL (domain-specific language)
- Compiles the DSL into executable JSON (obligation graph + constraint rules)
- Provides a runtime that adjudicates agent "slot proposals" against the compiled rules
- Supports bring-your-own-template via "Template Schema" + "Obligation → Slot Mapping"
- Produces ultra-atomic trace logs (paragraph/cell-level) and never allows untraced output
- Jurisdiction coverage: EU MDR PSUR requirements per MDCG 2022-21 + UK PMS/PSUR requirements per SI 2024/1368 expectations (as represented in provided WI)
- MUST be template-agnostic; the template is only a set of slots. Compliance comes only from the DSL.

## Tech stack (MUST)
- Python 3.11+
- pydantic v2 for schemas
- typer for CLI
- rich for CLI output
- sqlite (stdlib) for persistence OR jsonl files (choose sqlite by default, fallback jsonl)
- pytest for tests
- No web calls. No external services.

## Project Structure (MUST)
psur_orchestrator/
  pyproject.toml
  README.md
  psur_orchestrator/
    __init__.py
    cli.py
    storage/
      db.py
      models.py
      migrations.py
    dsl/
      __init__.py
      parser.py
      compiler.py
      ast.py
      examples/
        eu_psur.dsl
        uk_psur.dsl
        combined.dsl
    rules/
      __init__.py
      engine.py
      checks.py
      registry.py
    core/
      __init__.py
      types.py
      adjudication.py
      qualification.py
      trace.py
      renderer_stub.py
    schemas/
      compiled_obligations.schema.json
      compiled_rules.schema.json
      template_schema.schema.json
      mapping.schema.json
      evidence_atom.schema.json
      slot_proposal.schema.json
      adjudication_result.schema.json
      trace_node.schema.json
    data/
      compiled/
        eu_compiled.json
        uk_compiled.json
  tests/
    test_dsl_compile.py
    test_template_qualification.py
    test_adjudication_accept.py
    test_adjudication_reject.py
    test_trace_atomicity.py
    test_time_contiguity.py

## Core Concepts (MUST IMPLEMENT)
### A) DSL (the standard source-of-truth)
Create a minimal, strict DSL to express obligations and constraints.
The DSL must support:
- DECLARE SOURCE (id, jurisdiction, instrument, effective_date)
- DECLARE OBLIGATION (id, title, jurisdiction, mandatory, required_evidence_types, allowed_transformations, forbidden_transformations, required_time_scope, allowed_output_types, sources)
- DECLARE CONSTRAINT (id, severity BLOCK|WARN, trigger event, logic)
- OPTIONAL: “profiles” (EU-only, UK-only, combined)

Example DSL syntax (you can improve but keep it simple and parseable):

SOURCE "MDCG-2022-21§2.2.2" {
  jurisdiction: EU
  instrument: Guidance
  effective_date: 2022-12-01
}

OBLIGATION "EU.PSUR.CONTENT.PMCF_MAIN_FINDINGS" {
  title: "Include main findings of PMCF"
  jurisdiction: EU
  mandatory: true
  required_evidence_types: ["pmcf_summary"]
  required_time_scope: "psur_period"
  allowed_transformations: ["summarize", "cite", "cross_reference"]
  forbidden_transformations: ["infer", "invent", "re_weight_risk", "extrapolate"]
  allowed_output_types: ["narrative", "table_ref"]
  sources: ["MDCG-2022-21§2.2.2"]
}

CONSTRAINT "EU.PSUR.GROUPING.LEADING_DEVICE_FIXED" {
  severity: BLOCK
  trigger: "on_group_update"
  if: changed("leading_device")
  then: fail("Leading device cannot change. Issue a new PSUR.")
  sources: ["MDCG-2022-21§4.1"]
}

The parser must build an AST; the compiler must output compiled JSON artifacts:
- compiled obligations graph
- compiled constraint rule set

### B) Template schema + mapping
TemplateSchema: list of Slots.
Slot: slot_id, path, type (narrative|table|kv), required flag, constraints (optional).
Mapping: obligation_id -> one or more slot_ids, plus render rules like summarize_only, cite_evidence_atoms.

### C) Evidence registry
EvidenceAtom: immutable records with provenance hash.
Types include (at minimum):
- sales_volume
- population_estimate
- complaint_record
- non_serious_incident
- serious_incident
- fsca
- trend_report
- literature_review
- external_database_scan
- pmcf_summary
- capa_summary

### D) Slot proposals (what agents submit)
SlotProposal includes:
- proposal_id, agent_id, slot_id
- payload: narrative text OR kv pairs OR table structure
- evidence_atoms referenced (list of atom_ids)
- claimed_basis (list of source ids OR obligation ids)
- transformations used (must be a subset of allowed transformations for mapped obligations)

Agents are not implemented here; only the orchestrator runtime that adjudicates proposals.

### E) Compliance runtime / adjudication
Adjudication inputs:
- compiled obligations + rules
- template schema + mapping
- evidence atoms
- proposal

Adjudication must:
1) Resolve which obligations are mapped to the slot (via mapping)
2) For each mapped obligation:
   - confirm required evidence types exist among referenced atoms
   - confirm evidence atoms are within required_time_scope
   - confirm transformations are allowed and none forbidden
3) Evaluate relevant global constraints (time continuity, grouping rules, etc.) when triggered
4) If mandatory obligations are not satisfied, REJECT proposal with precise machine-readable reasons

Return AdjudicationResult:
- ACCEPTED or REJECTED
- list of check results
- rejection reasons (rule_id/obligation_id/message)

### F) Ultra-atomic trace
If and only if proposal is ACCEPTED:
- Create TraceNodes at atomic granularity:
  - narrative => paragraph-level (split by blank lines; each paragraph becomes a trace node)
  - table => cell-level trace nodes (each cell must have trace)
  - kv => per key trace node
Each TraceNode must contain:
- output_anchor (slot_id + fragment pointer)
- evidence_atoms
- transformations
- regulatory_basis (obligation ids)
- decision metadata (timestamp, agent_id, adjudication_id)

System must enforce: NO accepted output can exist without trace nodes.

### G) Template qualification (PASS/FAIL gate)
Build a function `qualify_template(compiled_obligations, template_schema, mapping)` that:
- Ensures every mandatory obligation is mapped to >=1 slot
- Ensures every mapped slot exists
- Ensures the slot types are compatible with obligation allowed_output_types
- Produces a QualificationReport:
  - PASS/FAIL
  - missing_mandatory_obligations
  - dangling_mappings
  - incompatible_slot_types
Orchestrator must refuse generation if qualification FAILS.

### H) Time & schedule contiguity
Implement a minimal period model:
- PSURPeriod(start_date, end_date)
- Enforce contiguity across versions for a PSUR reference number: no gaps, no overlaps.
Provide CLI to register PSUR periods and validate contiguity.

## CLI Commands (MUST)
typer app `psur` with:
- psur dsl compile <dsl_file> --out <compiled_json>
- psur template register <template_schema.json>
- psur mapping register <mapping.json>
- psur template qualify --template <id> --compiled <compiled_json>
- psur evidence add <evidence_atom.json>
- psur proposal submit <slot_proposal.json>
- psur proposal adjudicate <proposal_id> (prints ACCEPT/REJECT + reasons)
- psur trace export --psur_ref <ref> --out trace.jsonl
- psur demo seed (loads example DSL + example template + mapping + sample evidence)

## Example DSL files (MUST)
Provide:
- dsl/examples/eu_psur.dsl (at least 8 obligations + 4 constraints)
- dsl/examples/uk_psur.dsl (UK-specific obligations: statistical methodology, MHRA 3 working days availability process, UK comms processes; and schedule constraints)
- dsl/examples/combined.dsl which imports both (or duplicates cleanly) without conflicts

## Minimum obligations to encode (MUST)
EU (from MDCG PSUR content expectations):
- benefit-risk conclusions
- main PMCF findings
- sales volume
- population estimate & usage frequency (when practicable)
- serious incidents & FSCAs
- non-serious incidents / undesirable side effects
- trend reporting info
- literature review / databases & registries
- publicly available info about similar devices

EU grouping constraints:
- leading device defined and fixed
- leading device sets schedule
- grouping requires same notified body (represent as a constraint flag in data model)

UK obligations (from SI 2024/1368 expectations reflected in WI):
- specify device lifetime and PMS period concept
- UK-specific statistical methodology for significant increases
- UK patient/public engagement methodology (where appropriate)
- process to provide PSUR/PMSR to MHRA within 3 working days upon request
- UK comms with MHRA/UKRP/Approved Body processes
UK schedule constraints:
- class IIa every 2 years
- class IIb/III annually
(Represent schedule as constraints; period validation logic is required.)

## Tests (MUST)
- DSL compiles to valid compiled JSON
- Template qualification fails when a mandatory obligation is unmapped
- Adjudication rejects proposal if forbidden transformation is claimed
- Adjudication rejects proposal if evidence types missing
- Adjudication accepts proposal when everything matches
- Trace atomicity: accepted narrative produces >=1 trace node per paragraph; tables produce per cell
- Time contiguity: reject overlapping or gap periods

## Output quality requirements (MUST)
- Deterministic: same inputs => same outputs
- Reject loudly: machine-readable rejection reasons
- No silent omission: if data missing, the only allowed behavior is explicit "data not available" content, with trace indicating missing evidence and obligation still satisfied via "absence statement" rule ONLY IF the obligation allows it.
(Implement "absence statement" as a special allowed output if required_evidence_types are missing, but only when obligation has `allow_absence_statement: true`.)

## Renderer
Provide renderer_stub.py only (do NOT implement docx yet). It should:
- take template schema + accepted slot payloads
- output a simple markdown report for now (deterministic)
Later can be swapped with docx templating.

## Persistence
Use sqlite with tables:
- regulatory_sources
- compiled_obligations
- compiled_rules
- templates
- mappings
- evidence_atoms
- proposals
- adjudications
- trace_nodes
Provide migrations.py to init db.

## Deliverables
Commit-ready code. All tests passing. README with quickstart:
- compile DSL
- register template
- register mapping
- qualify template
- add evidence
- submit proposal
- adjudicate proposal
- export trace
