Here’s a premium Coverage Slot Queue design that’s deterministic, obligation-first, and brutally efficient. This is the thing you run after qualification + evidence ingest to tell the system (and agents) exactly what to fill next, in the right order, until the PSUR is complete.

I’m giving you:

The queue schema (what it returns)

The priority algorithm (how it orders work)

The queue builder logic (drop-in implementation plan)

An example queue output for both Annex I and FormQAR profiles

1) Coverage Slot Queue Output Schema

This is what your orchestrator should emit as the worklist.

{
  "psur_ref": "string",
  "profile": "MDCG_ANNEX_I|FORMQAR_054_C",
  "generated_at": "ISO-8601",
  "coverage_summary": {
    "mandatory_obligations_total": 0,
    "mandatory_obligations_satisfied": 0,
    "mandatory_obligations_remaining": 0,
    "required_slots_total": 0,
    "required_slots_filled": 0,
    "required_slots_remaining": 0
  },
  "queue": [
    {
      "queue_rank": 1,
      "slot_id": "string",
      "slot_path": "string",
      "slot_type": "narrative|table|kv|object|array",
      "requiredness": "required|conditional|required_if_applicable",
      "mapped_obligations": [
        {
          "obligation_id": "string",
          "requirement_level": "MUST|SHOULD|MUST_IF_APPLICABLE",
          "status": "unsatisfied|partially_satisfied|satisfied",
          "why_unsatisfied": ["string"]
        }
      ],
      "evidence_requirements": {
        "required_evidence_types": ["string"],
        "available_evidence_types": ["string"],
        "missing_evidence_types": ["string"],
        "period_check": "pass|fail|unknown"
      },
      "generation_contract": {
        "allowed_transformations": ["summarize|tabulate|aggregate|cite|cross_reference"],
        "forbidden_transformations": ["infer|invent|re_weight_risk|extrapolate"],
        "must_include": ["evidence_atom_ids", "method_description", "omissions_justification_if_any"],
        "trace_granularity": "paragraph|cell|key"
      },
      "dependencies": {
        "must_fill_before": [],
        "must_have_evidence_before": []
      },
      "recommended_agents": ["string"],
      "acceptance_criteria": [
        "string"
      ]
    }
  ]
}


This queue is not just “a list of sections.” It’s a legal-and-data-aware build plan.

2) Priority Rules (How the queue is ordered)

The orchestrator ranks slots using a scoring function. The premium version is obligation-driven and minimizes rework.

Priority tiers (highest → lowest)

Tier 0 — Gating identity & scope (must come first)

Manufacturer/device scope

Data collection period

Notified body identifiers

PSUR ref/version

Grouping + leading device (if applicable)

Why: you cannot safely interpret any data without knowing scope.

Tier 1 — Denominator & exposure

Sales volume methodology + tables

Population exposure estimate (or justified absence)

Anything that defines denominators for rates/trends

Why: everything downstream depends on denominators.

Tier 2 — Safety signals core

Serious incidents characterization + tables

FSCAs + CAPAs summaries

Trend reporting section

Why: these drive benefit–risk conclusions.

Tier 3 — Clinical & scientific context

PMCF summary

Literature review / external database findings

Similar devices info (where applicable)

Why: context for benefit-risk, not the initial math.

Tier 4 — Executive summary + overall conclusions

Exec summary

Benefit–risk acceptability statement

Actions recommended/taken

Why: summaries should be generated after the factual body is locked.

Ranking within a tier

Each slot gets a score:

Score =

+100 if it satisfies any MUST obligation currently unsatisfied

+40 if slot is required in the selected template profile

+30 if it unlocks downstream dependencies (denominator/exposure)

+25 if all required evidence types are already available

−50 if evidence is missing (so you don’t waste cycles generating content that will be rejected)

+10 per additional unsatisfied obligation it can satisfy (multi-coverage slots are valuable)

+15 if it’s a “repeatable table” slot (reduces narrative ambiguity)

Result: the system first fills what is both mandatory and feasible.

3) Queue Builder Logic (Deterministic)

This is the “engine” that produces the queue.

Inputs

compiled_obligations (from DSL compilation)

template_slots (Annex I or FormQAR profile)

mapping (obligation → slots)

psur_case (scope/period/jurisdiction/device list/grouping)

evidence_registry (available evidence types + atom IDs + date ranges)

accepted_payloads (already accepted slots for this PSUR)

Process (high level)

Compute obligation statuses:

satisfied if at least one accepted slot payload satisfies it

partially satisfied if content exists but missing required evidence/time/trace

Compute slot statuses:

filled if accepted payload exists

For each slot:

gather mapped obligations

determine which obligations remain unsatisfied

compute evidence requirements vs availability

compute dependencies (from obligation graph: e.g., benefit–risk depends on incidents + pmcf + literature)

Score and sort slots

Emit the queue with contracts + acceptance criteria

Key enforcement

If a slot is ranked high but evidence is missing, the queue should explicitly say:

“Acquire evidence X before proposing slot Y”
This prevents wasted agent cycles.

4) Coverage Slot Queue — Example Output (MDCG Annex I profile)

This is what you should see early in a run (fresh PSUR, nothing filled).

{
  "psur_ref": "ZYMOT-PSUR-001",
  "profile": "MDCG_ANNEX_I",
  "generated_at": "2026-01-09T18:00:00Z",
  "coverage_summary": {
    "mandatory_obligations_total": 24,
    "mandatory_obligations_satisfied": 0,
    "mandatory_obligations_remaining": 24,
    "required_slots_total": 38,
    "required_slots_filled": 0,
    "required_slots_remaining": 38
  },
  "queue": [
    {
      "queue_rank": 1,
      "slot_id": "cover.manufacturer_information",
      "slot_path": "Cover Page / Manufacturer information",
      "slot_type": "object",
      "requiredness": "required",
      "mapped_obligations": [
        {
          "obligation_id": "MDCG_COVER_MIN_FIELDS",
          "requirement_level": "MUST",
          "status": "unsatisfied",
          "why_unsatisfied": ["No accepted payload for cover minimum fields."]
        }
      ],
      "evidence_requirements": {
        "required_evidence_types": ["manufacturer_master_data"],
        "available_evidence_types": ["manufacturer_master_data"],
        "missing_evidence_types": [],
        "period_check": "pass"
      },
      "generation_contract": {
        "allowed_transformations": ["cite"],
        "forbidden_transformations": ["infer", "invent", "extrapolate", "re_weight_risk"],
        "must_include": ["evidence_atom_ids", "source_pointer"],
        "trace_granularity": "key"
      },
      "dependencies": {
        "must_fill_before": [],
        "must_have_evidence_before": []
      },
      "recommended_agents": ["IdentitySlotFiller"],
      "acceptance_criteria": [
        "Manufacturer legal name and address present.",
        "Trace nodes exist per key with evidence pointer."
      ]
    },
    {
      "queue_rank": 2,
      "slot_id": "cover.devices_covered",
      "slot_path": "Cover Page / Medical device(s) covered",
      "slot_type": "array",
      "requiredness": "required",
      "mapped_obligations": [
        {
          "obligation_id": "MDCG_COVER_MIN_FIELDS",
          "requirement_level": "MUST",
          "status": "unsatisfied",
          "why_unsatisfied": ["No accepted payload for devices covered."]
        }
      ],
      "evidence_requirements": {
        "required_evidence_types": ["device_master_data"],
        "available_evidence_types": ["device_master_data"],
        "missing_evidence_types": [],
        "period_check": "pass"
      },
      "generation_contract": {
        "allowed_transformations": ["cite"],
        "forbidden_transformations": ["infer", "invent", "extrapolate", "re_weight_risk"],
        "must_include": ["basic_udi_di_list", "evidence_atom_ids"],
        "trace_granularity": "key"
      },
      "dependencies": {
        "must_fill_before": [],
        "must_have_evidence_before": []
      },
      "recommended_agents": ["DeviceScopeAgent"],
      "acceptance_criteria": [
        "Lists all Basic UDI-DIs (or device identifiers) in scope.",
        "Trace contains evidence for each identifier."
      ]
    },
    {
      "queue_rank": 3,
      "slot_id": "cover.data_collection_period",
      "slot_path": "Cover Page / Data collection period",
      "slot_type": "object",
      "requiredness": "required",
      "mapped_obligations": [
        {
          "obligation_id": "MDCG_COVER_MIN_FIELDS",
          "requirement_level": "MUST",
          "status": "unsatisfied",
          "why_unsatisfied": ["No accepted payload for period."]
        }
      ],
      "evidence_requirements": {
        "required_evidence_types": ["psur_case_record"],
        "available_evidence_types": ["psur_case_record"],
        "missing_evidence_types": [],
        "period_check": "pass"
      },
      "generation_contract": {
        "allowed_transformations": ["cite"],
        "forbidden_transformations": ["infer", "invent", "extrapolate", "re_weight_risk"],
        "must_include": ["start_date", "end_date", "evidence_atom_ids"],
        "trace_granularity": "key"
      },
      "dependencies": {
        "must_fill_before": ["cover.devices_covered"],
        "must_have_evidence_before": []
      },
      "recommended_agents": ["PSURCaseAgent"],
      "acceptance_criteria": [
        "Start/end dates match PSUR case and pass contiguity checks.",
        "Trace nodes per date field."
      ]
    },
    {
      "queue_rank": 4,
      "slot_id": "sales.criteria_used",
      "slot_path": "Volume of sales / criteria",
      "slot_type": "array",
      "requiredness": "required",
      "mapped_obligations": [
        {
          "obligation_id": "EU.PSUR.CONTENT.SALES_AND_POPULATION",
          "requirement_level": "MUST",
          "status": "unsatisfied",
          "why_unsatisfied": ["Sales criteria not stated; denominators cannot be validated."]
        }
      ],
      "evidence_requirements": {
        "required_evidence_types": ["sales_volume"],
        "available_evidence_types": ["sales_volume"],
        "missing_evidence_types": [],
        "period_check": "pass"
      },
      "generation_contract": {
        "allowed_transformations": ["summarize", "cite"],
        "forbidden_transformations": ["infer", "invent", "extrapolate", "re_weight_risk"],
        "must_include": ["method_description", "evidence_atom_ids"],
        "trace_granularity": "paragraph"
      },
      "dependencies": {
        "must_fill_before": ["population.exposure_estimate"],
        "must_have_evidence_before": ["sales_volume"]
      },
      "recommended_agents": ["SalesMethodAgent"],
      "acceptance_criteria": [
        "States sales criteria used (placed on market, units distributed, etc.).",
        "Cites sales extract evidence atom IDs.",
        "No invented numbers."
      ]
    },
    {
      "queue_rank": 5,
      "slot_id": "population.exposure_estimate",
      "slot_path": "Population exposure / estimate",
      "slot_type": "object",
      "requiredness": "required",
      "mapped_obligations": [
        {
          "obligation_id": "EU.PSUR.CONTENT.SALES_AND_POPULATION",
          "requirement_level": "MUST",
          "status": "unsatisfied",
          "why_unsatisfied": ["Exposure estimate missing; complaint/incident rates cannot be computed."]
        }
      ],
      "evidence_requirements": {
        "required_evidence_types": ["population_estimate"],
        "available_evidence_types": [],
        "missing_evidence_types": ["population_estimate"],
        "period_check": "unknown"
      },
      "generation_contract": {
        "allowed_transformations": ["cite", "summarize"],
        "forbidden_transformations": ["infer", "invent", "extrapolate", "re_weight_risk"],
        "must_include": ["either_exposure_model_or_absence_justification", "evidence_atom_ids_or_justification_trace"],
        "trace_granularity": "paragraph"
      },
      "dependencies": {
        "must_fill_before": ["complaints.rate_metrics", "serious_incidents.rate_metrics"],
        "must_have_evidence_before": ["population_estimate"]
      },
      "recommended_agents": ["ExposureModelAgent"],
      "acceptance_criteria": [
        "If estimate exists: shows method + inputs and ties to sales/use assumptions.",
        "If estimate not available: explicit 'not available' + justification + impact statement."
      ]
    }
  ]
}


That queue already tells you what’s next and what will block acceptance.

5) Same idea, FormQAR profile (it will produce a different slot order)

The queue will target FormQAR slot IDs, but the priorities remain the same:

Cover + scope (FormQAR cover fields)

Denominators (Section C sales + exposure)

Serious incidents (Section D)

Complaints rate tables (Section F)

Trend reporting (G)

FSCA (H), CAPA (I)

Literature (J), Databases (K), PMCF (L)

Conclusions (M)

6) The “Coverage Slot Queue” function you should implement

Here’s a clean, implementable signature:

def build_coverage_slot_queue(
    psur_ref: str,
    profile_id: str,
    compiled_obligations: dict,
    template_schema: dict,
    mapping: dict,
    psur_case: dict,
    evidence_index: dict,
    accepted_payloads_index: dict
) -> dict:
    """
    Returns Coverage Slot Queue JSON described above.
    Deterministic ordering.
    """

Minimal evidence index structure
{
  "available_evidence_types": ["sales_volume", "complaint_record"],
  "evidence_by_type": {
    "sales_volume": ["EVT-sales-001"],
    "complaint_record": ["EVT-compl-120", "EVT-compl-121"]
  },
  "period_coverage": {
    "sales_volume": { "start": "2023-01-01", "end": "2024-12-31" }
  }
}