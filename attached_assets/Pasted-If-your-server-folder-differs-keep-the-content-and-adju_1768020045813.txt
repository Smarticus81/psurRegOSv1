If your server folder differs, keep the content and adjust the import paths.

// server/evidence/normalize.ts
import crypto from "crypto";

export function toISODate(value: any): string | null {
  if (value == null || value === "") return null;

  // Already YYYY-MM-DD
  if (typeof value === "string") {
    const s = value.trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;

    // Common mm/dd/yyyy
    const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (m) {
      const mm = m[1].padStart(2, "0");
      const dd = m[2].padStart(2, "0");
      const yyyy = m[3];
      return `${yyyy}-${mm}-${dd}`;
    }

    // Try Date parse as last resort
    const d = new Date(s);
    if (!isNaN(d.getTime())) return d.toISOString().slice(0, 10);
    return null;
  }

  // Excel serial date number
  if (typeof value === "number") {
    // Excel epoch: 1899-12-30 (accounts for Excel leap-year bug)
    const excelEpoch = new Date(Date.UTC(1899, 11, 30));
    const d = new Date(excelEpoch.getTime() + value * 86400000);
    return d.toISOString().slice(0, 10);
  }

  // JS Date
  if (value instanceof Date && !isNaN(value.getTime())) {
    return value.toISOString().slice(0, 10);
  }

  return null;
}

export function toBool(value: any): boolean | null {
  if (value == null || value === "") return null;
  if (typeof value === "boolean") return value;
  if (typeof value === "number") return value !== 0;
  if (typeof value === "string") {
    const s = value.trim().toLowerCase();
    if (["true", "yes", "y", "1"].includes(s)) return true;
    if (["false", "no", "n", "0"].includes(s)) return false;
  }
  return null;
}

export function sha256Hex(input: string) {
  return crypto.createHash("sha256").update(input).digest("hex");
}

export function makeAtomId(prefix: string) {
  return `${prefix}-${crypto.randomBytes(8).toString("hex")}`;
}

export function normalizeEnum(value: any): string | null {
  if (value == null || value === "") return null;
  return String(value).trim().toLowerCase();
}

export function normalizeComplaintRecordRowToAtom(args: {
  row: Record<string, any>;
  psurRef: string | null;
  jurisdictions: ("EU_MDR" | "UK")[];
  psurPeriod: { start_date: string; end_date: string };
  provenance: any;
}) {
  const { row, psurRef, jurisdictions, psurPeriod, provenance } = args;

  const event_date = toISODate(row.event_date);
  const received_date = toISODate(row.received_date);

  const atom = {
    atom_id: makeAtomId("EVA"),
    atom_type: "complaint_record",
    jurisdictions,
    device_ref: {
      device_name: String(row.device_name || "").trim(),
      basic_udi_di: String(row.basic_udi_di || "").trim(),
      catalog_number: String(row.catalog_number || "").trim(),
    },
    psur_period: psurPeriod,
    provenance,
    created_at: new Date().toISOString(),
    immutability: {
      is_immutable: true,
      content_hash: "", // fill below
    },

    // complaint payload (must match schema)
    complaint: {
      complaint_id: String(row.complaint_id || "").trim(),
      event_date: event_date,
      received_date: received_date,
      country: String(row.country || "").trim(),
      region: row.region ? String(row.region).trim() : undefined,

      seriousness: normalizeEnum(row.seriousness),
      event_type: normalizeEnum(row.event_type),

      problem_code: {
        scheme: row.problem_code_scheme ? String(row.problem_code_scheme).trim() : "UNKNOWN",
        code: String(row.problem_code || "").trim(),
        term: row.problem_code_term ? String(row.problem_code_term).trim() : undefined,
      },

      health_impact: {
        impact_level: normalizeEnum(row.health_impact_level),
        description: row.health_impact_description ? String(row.health_impact_description).trim() : undefined,
      },

      investigation_status: normalizeEnum(row.investigation_status),
      investigation_conclusion: row.investigation_conclusion ? String(row.investigation_conclusion).trim() : undefined,

      capa_linked: toBool(row.capa_linked) ?? false,
      capa_id: row.capa_id ? String(row.capa_id).trim() : undefined,

      fsca_linked: toBool(row.fsca_linked) ?? false,
      fsca_id: row.fsca_id ? String(row.fsca_id).trim() : undefined,

      narrative_summary: row.narrative_summary ? String(row.narrative_summary).trim() : undefined,
    },

    // optional: store psur_ref if your db expects it
    psur_ref: psurRef || undefined,
  };

  // hash normalized payload excluding content_hash itself
  const clone = JSON.parse(JSON.stringify(atom));
  clone.immutability.content_hash = "";
  atom.immutability.content_hash = sha256Hex(JSON.stringify(clone));

  return atom;
}