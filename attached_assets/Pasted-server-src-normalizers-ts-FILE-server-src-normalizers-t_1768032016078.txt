server/src/normalizers.ts
// FILE: server/src/normalizers.ts
// SOTA hardening layer: converts "legacy/demo" atoms+proposals into strict schema-shaped objects.
// This runs BEFORE validation so your pipeline never dies on missing trace fields.

import crypto from "crypto";

function sha256Hex(input: string) {
  return crypto.createHash("sha256").update(input).digest("hex");
}

function stableStringify(obj: any) {
  try {
    return JSON.stringify(obj, Object.keys(obj || {}).sort());
  } catch {
    return JSON.stringify(obj);
  }
}

function ensureString(v: any, fallback: string) {
  if (typeof v === "string" && v.trim().length > 0) return v;
  return fallback;
}

function ensureStringArray(v: any, fallback: string[]) {
  if (Array.isArray(v) && v.every((x) => typeof x === "string" && x.length > 0) && v.length > 0) return v;
  return fallback;
}

function ensureObject(v: any, fallback: any) {
  if (v && typeof v === "object" && !Array.isArray(v)) return v;
  return fallback;
}

function inferAtomType(a: any): string {
  // Prefer explicit type/evidenceType, else infer from presence of common fields
  const t = a?.type || a?.evidenceType || a?.evidence_type;
  if (typeof t === "string") return t;

  const n = a?.normalizedData || a?.data || {};
  if (n?.complaintId || n?.complaintDate) return "complaint_record";
  if (n?.incidentId || n?.imdrfCode) return "incident_record";
  if (n?.fscaId || n?.fscaDate) return "fsca_record";
  if (n?.studyId || n?.pmcf) return "pmcf_result";
  if (n?.pubmedId || n?.doi) return "literature_result";
  return "sales_volume";
}

export function normalizeEvidenceAtoms(rawAtoms: any[], ctx?: { deviceCode?: string; periodStart?: string; periodEnd?: string }) {
  const atoms = Array.isArray(rawAtoms) ? rawAtoms : [];

  return atoms.map((a, idx) => {
    // Accept many legacy shapes:
    // - { normalizedData, provenance }
    // - { data, provenance }
    // - { row, meta }
    const normalizedData =
      a?.normalizedData ??
      a?.data ??
      a?.row ??
      a?.normalized ??
      a ??
      {};

    const type = inferAtomType(a);

    const provenance = ensureObject(a?.provenance, {
      uploadId: a?.uploadId ?? a?.upload?.id ?? 0,
      sourceFile: a?.sourceFile ?? a?.upload?.filename ?? a?.filename ?? "unknown",
      extractedAt: a?.extractedAt ?? a?.uploadedAt ?? new Date().toISOString(),
      deviceRef: { deviceCode: ctx?.deviceCode || a?.deviceCode || normalizedData?.deviceCode || "UNKNOWN_DEVICE" },
      psurPeriod: { periodStart: ctx?.periodStart || "UNKNOWN_START", periodEnd: ctx?.periodEnd || "UNKNOWN_END" },
      filters: a?.filters ?? {},
    });

    // Compute contentHash if missing
    const contentHash = ensureString(
      a?.contentHash,
      sha256Hex(stableStringify({ type, normalizedData, provenance, idx }))
    );

    // Compute atomId if missing
    const atomId = ensureString(
      a?.atomId,
      `${type}:${contentHash.slice(0, 12)}`
    );

    // Ensure "data" exists (your Zod expects it)
    const data = a?.data ?? normalizedData;

    return {
      atomId,
      type,
      version: typeof a?.version === "number" ? a.version : 1,
      contentHash,
      data,
      normalizedData,
      provenance,
    };
  });
}

export function normalizeSlotProposals(
  rawProposals: any[],
  template?: any
) {
  const proposals = Array.isArray(rawProposals) ? rawProposals : [];

  return proposals.map((p, idx) => {
    const slotId = p?.slotId || p?.slot_id || p?.slot || `UNKNOWN_SLOT_${idx}`;
    const psurRef = p?.psurRef || p?.psur_ref || p?.caseRef || p?.case_ref || "UNKNOWN_PSUR_REF";
    const content = typeof p?.content === "string" ? p.content : (typeof p?.text === "string" ? p.text : "");

    // evidenceAtomIds required >= 1 for traceability
    const evidenceAtomIds = ensureStringArray(p?.evidenceAtomIds, ensureStringArray(p?.evidence_atom_ids, []));
    const fixedEvidenceAtomIds = evidenceAtomIds.length ? evidenceAtomIds : ["TRACE_ATOM_MISSING_FIXME"];

    // claimedObligationIds required >= 1; try pull from template mapping
    const fromTemplate =
      template?.mapping?.[slotId] ||
      template?.mapping?.[p?.slot_id] ||
      [];
    const claimedObligationIds = ensureStringArray(p?.claimedObligationIds, ensureStringArray(p?.claimed_obligation_ids, fromTemplate));
    const fixedClaimedObligationIds = claimedObligationIds.length ? claimedObligationIds : ["TRACE_OBLIGATION_MISSING_FIXME"];

    // methodStatement required min 10 chars
    const methodStatement =
      typeof p?.methodStatement === "string" && p.methodStatement.trim().length >= 10
        ? p.methodStatement
        : `Evidence used to support slot ${slotId} with traceability references.`;

    const proposalId = ensureString(
      p?.proposalId,
      `prop-${crypto.randomBytes(6).toString("hex")}`
    );

    return {
      ...p,
      proposalId,
      psurRef,
      slotId,
      content: content || `[[DEMO CONTENT]] Slot ${slotId} content placeholder.`,
      evidenceAtomIds: fixedEvidenceAtomIds,
      claimedObligationIds: fixedClaimedObligationIds,
      methodStatement,
      transformations: Array.isArray(p?.transformations) ? p.transformations : ["summarize", "cite"],
      createdAt: typeof p?.createdAt === "string" ? p.createdAt : new Date().toISOString(),
    };
  });
}

2) COPY/PASTE SNIPPET: patch Step 3 validation (EvidenceAtoms)

Find the orchestrator route where Step 3 ingests atoms and then does Zod validation. Right before you validate/persist atoms, add:

import { normalizeEvidenceAtoms } from "./src/normalizers";


Then right before your EvidenceAtomZ.parse(...) / EvidenceAtomZ.array().parse(...) call, do:

atoms = normalizeEvidenceAtoms(atoms, {
  deviceCode: device?.deviceCode || device?.code || "UNKNOWN_DEVICE",
  periodStart,
  periodEnd,
});

// Optional: debug one atom so you can see the real shape in logs
console.log("[DEBUG] atom sample", atoms?.[0]);

3) COPY/PASTE SNIPPET: patch Step 4 validation (SlotProposals)

In the same orchestrator file, wherever Step 4 generates proposals and then validates them, import:

import { normalizeSlotProposals } from "./src/normalizers";


Then right before proposal validation, do:

proposals = normalizeSlotProposals(proposals, template);

// Optional: debug one proposal so you can see the real shape in logs
console.log("[DEBUG] proposal sample", proposals?.[0]);

4) COPY/PASTE SNIPPET: fix the “42 ACCEPTED but 0 accepted” logging bug

This means your adjudicator is storing the decision in a different field than your counter expects.

Add this right after adjudication:

const accepted = proposals.filter((p: any) => (p.adjudication || p.decision) === "ACCEPTED").length;
const rejected = proposals.filter((p: any) => (p.adjudication || p.decision) === "REJECTED").length;
console.log(`Adjudication: ${accepted} ACCEPTED, ${rejected} REJECTED`);
