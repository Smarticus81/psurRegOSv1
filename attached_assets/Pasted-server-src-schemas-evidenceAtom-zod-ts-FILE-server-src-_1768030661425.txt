server/src/schemas/evidenceAtom.zod.ts
// FILE: server/src/schemas/evidenceAtom.zod.ts

import { z } from "zod";

export const EvidenceAtomZ = z.object({
  atomId: z.string().min(5),
  type: z.enum([
    "sales_volume",
    "complaint_record",
    "incident_record",
    "fsca_record",
    "pmcf_result",
    "literature_result",
  ]),
  version: z.number().int().min(1).default(1),
  contentHash: z.string().min(16),

  // canonical payload used for downstream summarization/tabulation
  data: z.union([z.string(), z.number(), z.boolean(), z.null(), z.object({}).passthrough(), z.array(z.any())]),

  normalizedData: z.object({}).passthrough().optional(),

  provenance: z.object({
    uploadId: z.number().int(),
    sourceFile: z.string(),
    extractedAt: z.string(), // ISO string
    deviceRef: z.object({
      deviceCode: z.string(),
    }),
    psurPeriod: z.object({
      periodStart: z.string(), // YYYY-MM-DD
      periodEnd: z.string(),   // YYYY-MM-DD
    }),
    filters: z.object({}).passthrough().optional(),
  }),
});

export type EvidenceAtom = z.infer<typeof EvidenceAtomZ>;

2) COPY/PASTE SNIPPET: fix your ingest output shape (the real bug)

Find the code in Step 3 where you construct atoms. Replace your atom creation with this exact pattern:

// COPY/PASTE: canonical atom builder (use this in Step 3 ingest)

import crypto from "crypto";
import { EvidenceAtomZ } from "../schemas/evidenceAtom.zod";

function stableHash(obj: any) {
  const json = JSON.stringify(obj, Object.keys(obj).sort());
  return crypto.createHash("sha256").update(json).digest("hex");
}

function buildAtom(params: {
  type: any;
  normalizedData: any;
  provenance: any;
}) {
  const contentHash = stableHash({
    type: params.type,
    normalizedData: params.normalizedData,
    provenance: params.provenance,
  });

  const atom = {
    atomId: `${params.type}:${contentHash.slice(0, 12)}`,
    type: params.type,
    version: 1,
    contentHash,
    data: params.normalizedData,        // <-- IMPORTANT: 'data' must exist
    normalizedData: params.normalizedData,
    provenance: params.provenance,
  };

  // hard fail early if schema mismatch
  return EvidenceAtomZ.parse(atom);
}


Then wherever you currently push atoms, do:

atoms.push(
  buildAtom({
    type: "complaint_record",
    normalizedData,
    provenance,
  })
);


This guarantees atomId, contentHash, and data exist every time.

3) COPY/PASTE FILE: server/src/schemas/slotProposal.schema.json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "SlotProposal",
  "type": "object",
  "required": [
    "proposalId",
    "psurRef",
    "slotId",
    "content",
    "evidenceAtomIds",
    "claimedObligationIds",
    "methodStatement",
    "createdAt"
  ],
  "properties": {
    "proposalId": { "type": "string", "minLength": 8 },
    "psurRef": { "type": "string", "minLength": 5 },
    "slotId": { "type": "string", "minLength": 5 },
    "content": { "type": "string", "minLength": 1 },
    "evidenceAtomIds": {
      "type": "array",
      "minItems": 1,
      "items": { "type": "string", "minLength": 5 }
    },
    "claimedObligationIds": {
      "type": "array",
      "minItems": 1,
      "items": { "type": "string", "minLength": 5 }
    },
    "methodStatement": { "type": "string", "minLength": 10 },
    "transformations": {
      "type": "array",
      "items": { "type": "string" }
    },
    "createdAt": { "type": "string", "minLength": 10 }
  },
  "additionalProperties": true
}

4) COPY/PASTE SNIPPET: Force proposals to include the missing fields (Step 4 fix)

Where Step 4 builds a proposal object, replace it with:

// COPY/PASTE: proposal builder that ALWAYS satisfies schema

import crypto from "crypto";

function makeId(prefix: string) {
  return `${prefix}-${crypto.randomBytes(6).toString("hex")}`;
}

function buildProposal(params: {
  psurRef: string;
  slotId: string;
  content: string;
  evidenceAtomIds: string[];
  claimedObligationIds: string[];
  transformations?: string[];
}) {
  return {
    proposalId: makeId("prop"),
    psurRef: params.psurRef,
    slotId: params.slotId,
    content: params.content,
    evidenceAtomIds: params.evidenceAtomIds.length ? params.evidenceAtomIds : ["MISSING_ATOM_FIXME"],
    claimedObligationIds: params.claimedObligationIds.length
      ? params.claimedObligationIds
      : ["MISSING_OBLIGATION_FIXME"],
    methodStatement:
      `Generated for slot ${params.slotId} from ${params.evidenceAtomIds.length} evidence atoms; ` +
      `transformations: ${(params.transformations || ["summarize"]).join(", ")}`,
    transformations: params.transformations || ["summarize"],
    createdAt: new Date().toISOString(),
  };
}


Now when you generate each slot proposal, do:

const claimed = template.mapping?.[slot.slot_id] || [];
const evidenceIds = matchingAtoms.map((a: any) => a.atomId);

const proposal = buildProposal({
  psurRef,
  slotId: slot.slot_id,
  content: generatedContent,
  evidenceAtomIds: evidenceIds,
  claimedObligationIds: claimed,
  transformations: ["summarize", "cite"],
});


This fixes the “Slot proposal validation failed” error for real, not by weakening validation.

5) COPY/PASTE SNIPPET: Fix the adjudication counter log

Find the line that prints:

0 proposals adjudicated as ACCEPTED

Replace your counter logic with:

// COPY/PASTE: correct accepted/rejected counting
const accepted = proposals.filter((p: any) => p.adjudication === "ACCEPTED").length;
const rejected = proposals.filter((p: any) => p.adjudication === "REJECTED").length;

console.log(`Adjudication: ${accepted} ACCEPTED, ${rejected} REJECTED`);